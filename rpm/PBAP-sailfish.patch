diff -Naur obexd.orig/Makefile.am obexd/Makefile.am
--- obexd.orig/Makefile.am	2014-01-17 08:52:59.481060135 +0200
+++ obexd/Makefile.am	2014-01-17 08:53:12.283457605 +0200
@@ -149,6 +149,7 @@
 			src/obexd.service.in client/obex-client.service.in \
 			plugins/phonebook-dummy.c plugins/phonebook-ebook.c \
 			plugins/phonebook-tracker.c \
+			plugins/phonebook-sailfish.c \
 			plugins/messages-dummy.c plugins/messages-tracker.c
 
 DISTCHECK_CONFIGURE_FLAGS = --enable-client --enable-server
diff -Naur obexd.orig/plugins/irmc.c obexd/plugins/irmc.c
--- obexd.orig/plugins/irmc.c	2014-01-17 08:52:59.481060135 +0200
+++ obexd/plugins/irmc.c	2014-01-17 14:32:45.245750283 +0200
@@ -110,6 +110,7 @@
 	char manu[DID_LEN];
 	char model[DID_LEN];
 	void *request;
+	void *backend_data;
 };
 
 #define IRMC_TARGET_SIZE 9
@@ -204,11 +205,17 @@
 
 	DBG("");
 
-	manager_register_session(os);
-
 	irmc = g_new0(struct irmc_session, 1);
 	irmc->os = os;
 
+	ret = phonebook_connect(&irmc->backend_data);
+	if (ret < 0) {
+		g_free(irmc);
+		return NULL;
+	}
+
+	manager_register_session(os);
+
 	/* FIXME:
 	 * Ideally get capabilities info here and use that to define
 	 * IrMC DID and SN etc parameters.
@@ -226,7 +233,8 @@
 	param->maxlistcount = 0; /* to count the number of vcards... */
 	param->filter = 0x200085; /* UID TEL N VERSION */
 	irmc->params = param;
-	irmc->request = phonebook_pull(PB_CONTACTS, irmc->params,
+	irmc->request = phonebook_pull(irmc->backend_data,
+					PB_CONTACTS, irmc->params,
 					phonebook_size_result, irmc, err);
 	ret = phonebook_pull_read(irmc->request);
 	if (err)
@@ -260,6 +268,8 @@
 
 	DBG("");
 
+	phonebook_disconnect(irmc->backend_data);
+
 	manager_unregister_session(os);
 
 	if (irmc->params) {
@@ -309,7 +319,8 @@
 	int ret;
 
 	/* how can we tell if the vcard count call already finished? */
-	irmc->request = phonebook_pull(PB_CONTACTS, irmc->params,
+	irmc->request = phonebook_pull(irmc->backend_data,
+						PB_CONTACTS, irmc->params,
 						query_result, irmc, &ret);
 	if (ret < 0) {
 		DBG("phonebook_pull failed...");
diff -Naur obexd.orig/plugins/pbap.c obexd/plugins/pbap.c
--- obexd.orig/plugins/pbap.c	2014-01-17 08:52:59.481060135 +0200
+++ obexd/plugins/pbap.c	2014-01-17 14:32:28.941750963 +0200
@@ -128,6 +128,7 @@
 	uint32_t find_handle;
 	struct cache cache;
 	struct pbap_object *obj;
+	void *backend_data;
 };
 
 struct pbap_object {
@@ -233,6 +234,7 @@
 
 	phonebooksize = htons(vcards);
 
+	pbap->obj->firstpacket = TRUE;
 	pbap->obj->apparam = g_obex_apparam_set_uint16(NULL, PHONEBOOKSIZE_TAG,
 								phonebooksize);
 
@@ -480,8 +482,9 @@
 	}
 
 	phonebook_req_finalize(pbap->obj->request);
-	pbap->obj->request = phonebook_get_entry(pbap->folder, id,
-				pbap->params, query_result, pbap, &ret);
+	pbap->obj->request = phonebook_get_entry(pbap->backend_data,
+						pbap->folder, id, pbap->params,
+						query_result, pbap, &ret);
 	if (ret < 0)
 		obex_object_set_io_flags(pbap->obj, G_IO_ERR, ret);
 }
@@ -521,15 +524,30 @@
 static void *pbap_connect(struct obex_session *os, int *err)
 {
 	struct pbap_session *pbap;
+	int e = 0;
 
-	manager_register_session(os);
+	DBG("");
 
 	pbap = g_new0(struct pbap_session, 1);
 	pbap->folder = g_strdup("/");
 	pbap->find_handle = PHONEBOOK_INVALID_HANDLE;
 
+	e = phonebook_connect(&pbap->backend_data);
+	if (e < 0) {
+		goto exit;
+	}
+
+	manager_register_session(os);
+
+exit:
+	if (e < 0) {
+		g_free(pbap->folder);
+		g_free(pbap);
+		pbap = NULL;
+	}
+
 	if (err)
-		*err = 0;
+		*err = e;
 
 	return pbap;
 }
@@ -619,7 +637,8 @@
 	DBG("name %s folder %s nonhdr 0x%x%x", name, pbap->folder,
 							nonhdr[0], nonhdr[1]);
 
-	fullname = phonebook_set_folder(pbap->folder, name, nonhdr[0], &err);
+	fullname = phonebook_set_folder(pbap->backend_data, pbap->folder, name,
+					nonhdr[0], &err);
 	if (err < 0)
 		return err;
 
@@ -640,6 +659,9 @@
 {
 	struct pbap_session *pbap = user_data;
 
+	phonebook_disconnect(pbap->backend_data);
+	pbap->backend_data = NULL;
+
 	manager_unregister_session(os);
 
 	if (pbap->obj)
@@ -715,7 +737,8 @@
 	else
 		cb = query_result;
 
-	request = phonebook_pull(name, pbap->params, cb, pbap, &ret);
+	request = phonebook_pull(pbap->backend_data, name, pbap->params, cb,
+				pbap, &ret);
 
 	if (ret < 0)
 		goto fail;
@@ -740,6 +763,7 @@
 static int vobject_close(void *object)
 {
 	struct pbap_object *obj = object;
+	struct pbap_session *pbap = obj->session;
 
 	DBG("");
 
@@ -786,7 +810,8 @@
 		obj = vobject_create(pbap, NULL);
 		ret = generate_response(pbap);
 	} else {
-		request = phonebook_create_cache(name, cache_entry_notify,
+		request = phonebook_create_cache(pbap->backend_data,
+					name, cache_entry_notify,
 					cache_ready_notify, pbap, &ret);
 		if (ret == 0)
 			obj = vobject_create(pbap, request);
@@ -832,8 +857,9 @@
 
 	if (pbap->cache.valid == FALSE) {
 		pbap->find_handle = handle;
-		request = phonebook_create_cache(pbap->folder,
-			cache_entry_notify, cache_entry_done, pbap, &ret);
+		request = phonebook_create_cache(pbap->backend_data,
+			pbap->folder, cache_entry_notify, cache_entry_done,
+			pbap, &ret);
 		goto done;
 	}
 
@@ -843,8 +869,8 @@
 		goto fail;
 	}
 
-	request = phonebook_get_entry(pbap->folder, id, pbap->params,
-						query_result, pbap, &ret);
+	request = phonebook_get_entry(pbap->backend_data, pbap->folder, id,
+				pbap->params, query_result, pbap, &ret);
 
 done:
 	if (ret < 0)
@@ -866,14 +892,13 @@
 								uint8_t *hi)
 {
 	struct pbap_object *obj = object;
-	struct pbap_session *pbap = obj->session;
 
 	if (!obj->buffer && !obj->apparam)
 		return -EAGAIN;
 
 	*hi = G_OBEX_HDR_APPARAM;
 
-	if (pbap->params->maxlistcount == 0 || obj->firstpacket) {
+	if (obj->firstpacket) {
 		obj->firstpacket = FALSE;
 
 		return g_obex_apparam_encode(obj->apparam, buf, mtu);
diff -Naur obexd.orig/plugins/phonebook-dummy.c obexd/plugins/phonebook-dummy.c
--- obexd.orig/plugins/phonebook-dummy.c	2014-01-17 08:52:59.481060135 +0200
+++ obexd/plugins/phonebook-dummy.c	2014-01-17 14:32:58.553749729 +0200
@@ -102,6 +102,16 @@
 	root_folder = NULL;
 }
 
+int phonebook_connect(void **session)
+{
+	return 0;
+}
+
+void phonebook_disconnect(void *session)
+{
+	return 0;
+}
+
 static int handle_cmp(gconstpointer a, gconstpointer b)
 {
 	const char *f1 = a;
@@ -364,7 +374,7 @@
 	return S_ISDIR(st.st_mode);
 }
 
-char *phonebook_set_folder(const char *current_folder,
+char *phonebook_set_folder(void *session, const char *current_folder,
 		const char *new_folder, uint8_t flags, int *err)
 {
 	gboolean root, child;
@@ -457,8 +467,9 @@
 		g_source_remove(dummy->id);
 }
 
-void *phonebook_pull(const char *name, const struct apparam_field *params,
-				phonebook_cb cb, void *user_data, int *err)
+void *phonebook_pull(void *session, const char *name,
+		const struct apparam_field *params, phonebook_cb cb,
+		void *user_data, int *err)
 {
 	struct dummy_data *dummy;
 	char *filename, *folder;
@@ -513,7 +524,7 @@
 	return 0;
 }
 
-void *phonebook_get_entry(const char *folder, const char *id,
+void *phonebook_get_entry(void *session, const char *folder, const char *id,
 			const struct apparam_field *params, phonebook_cb cb,
 			void *user_data, int *err)
 {
@@ -547,8 +558,10 @@
 	return GINT_TO_POINTER(ret);
 }
 
-void *phonebook_create_cache(const char *name, phonebook_entry_cb entry_cb,
-		phonebook_cache_ready_cb ready_cb, void *user_data, int *err)
+void *phonebook_create_cache(void *session, const char *name,
+			phonebook_entry_cb entry_cb,
+			phonebook_cache_ready_cb ready_cb, void *user_data,
+			int *err)
 {
 	struct cache_query *query;
 	char *foldername;
diff -Naur obexd.orig/plugins/phonebook-ebook.c obexd/plugins/phonebook-ebook.c
--- obexd.orig/plugins/phonebook-ebook.c	2014-01-17 08:52:59.481060135 +0200
+++ obexd/plugins/phonebook-ebook.c	2014-01-17 14:33:08.165749328 +0200
@@ -449,7 +449,17 @@
 {
 }
 
-char *phonebook_set_folder(const char *current_folder,
+int phonebook_connect(void **session)
+{
+	return 0;
+}
+
+void phonebook_disconnect(void *session)
+{
+	return 0;
+}
+
+char *phonebook_set_folder(void *session, const char *current_folder,
 		const char *new_folder, uint8_t flags, int *err)
 {
 	gboolean root, child;
@@ -543,8 +553,9 @@
 		data->canceled = TRUE;
 }
 
-void *phonebook_pull(const char *name, const struct apparam_field *params,
-				phonebook_cb cb, void *user_data, int *err)
+void *phonebook_pull(void *session, const char *name,
+		const struct apparam_field *params, phonebook_cb cb,
+		void *user_data, int *err)
 {
 	struct query_context *data;
 
@@ -594,7 +605,7 @@
 	return 0;
 }
 
-void *phonebook_get_entry(const char *folder, const char *id,
+void *phonebook_get_entry(void *session, const char *folder, const char *id,
 				const struct apparam_field *params,
 				phonebook_cb cb, void *user_data, int *err)
 {
@@ -625,8 +636,10 @@
 	return data;
 }
 
-void *phonebook_create_cache(const char *name, phonebook_entry_cb entry_cb,
-		phonebook_cache_ready_cb ready_cb, void *user_data, int *err)
+void *phonebook_create_cache(void *session, const char *name,
+			phonebook_entry_cb entry_cb,
+			phonebook_cache_ready_cb ready_cb, void *user_data,
+			int *err)
 {
 	struct query_context *data;
 	EBookQuery *query;
diff -Naur obexd.orig/plugins/phonebook.h obexd/plugins/phonebook.h
--- obexd.orig/plugins/phonebook.h	2014-01-17 08:52:59.481060135 +0200
+++ obexd/plugins/phonebook.h	2014-01-17 14:31:01.341754615 +0200
@@ -91,6 +91,9 @@
 int phonebook_init(void);
 void phonebook_exit(void);
 
+int phonebook_connect(void **session);
+void phonebook_disconnect(void *session);
+
 /*
  * Changes the current folder in the phonebook back-end. The PBAP core
  * doesn't validate or restrict the possible values for the folders,
@@ -98,8 +101,9 @@
  * the PBAP virtual folder architecture. Validate the folder's name
  * is responsibility of the back-ends.
 */
-char *phonebook_set_folder(const char *current_folder,
-		const char *new_folder, uint8_t flags, int *err);
+char *phonebook_set_folder(void *session, const char *current_folder,
+				const char *new_folder, uint8_t flags,
+				int *err);
 
 /*
  * phonebook_pull should be used only to prepare pull request - prepared
@@ -109,7 +113,8 @@
  *
  * phonebook_req_finalize MUST always be used to free associated resources.
  */
-void *phonebook_pull(const char *name, const struct apparam_field *params,
+void *phonebook_pull(void *session, const char *name,
+				const struct apparam_field *params,
 				phonebook_cb cb, void *user_data, int *err);
 
 /*
@@ -133,7 +138,7 @@
  * Return value is a pointer to asynchronous request to phonebook back-end.
  * phonebook_req_finalize MUST always be used to free associated resources.
  */
-void *phonebook_get_entry(const char *folder, const char *id,
+void *phonebook_get_entry(void *session, const char *folder, const char *id,
 				const struct apparam_field *params,
 				phonebook_cb cb, void *user_data, int *err);
 
@@ -147,8 +152,10 @@
  * Return value is a pointer to asynchronous request to phonebook back-end.
  * phonebook_req_finalize MUST always be used to free associated resources.
  */
-void *phonebook_create_cache(const char *name, phonebook_entry_cb entry_cb,
-		phonebook_cache_ready_cb ready_cb, void *user_data, int *err);
+void *phonebook_create_cache(void *session, const char *name,
+				phonebook_entry_cb entry_cb,
+				phonebook_cache_ready_cb ready_cb,
+				void *user_data, int *err);
 
 /*
  * Finalizes request to phonebook back-end and deallocates associated
diff -Naur obexd.orig/plugins/phonebook-sailfish.c obexd/plugins/phonebook-sailfish.c
--- obexd.orig/plugins/phonebook-sailfish.c	1970-01-01 02:00:00.000000000 +0200
+++ obexd/plugins/phonebook-sailfish.c	2014-01-20 11:44:37.289526781 +0200
@@ -0,0 +1,717 @@
+/*
+ *  Phonebook access through D-Bus vCard and call history service
+ *
+ *  Copyright (C) 2013 Jolla Ltd.
+ *  Contact: Hannu Mallat <hannu.mallat@jollamobile.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <errno.h>
+#include <glib.h>
+#include <dbus/dbus.h>
+
+#include "log.h"
+#include "phonebook.h"
+#include "obex.h"
+#include "manager.h"
+
+#define CONTACTS_SERVICE "com.jolla.Contacts"
+#define CONTACTS_PATH "/contacts"
+#define CONTACTS_INTERFACE "com.jolla.Contacts"
+#define CONTACTS_METHOD_FETCH_COUNT "Count"
+#define CONTACTS_METHOD_FETCH_ONE "FetchById"
+#define CONTACTS_METHOD_FETCH_MANY "Fetch"
+
+#define CALLHIST_SERVICE "com.jolla.CallHistory"
+#define CALLHIST_PATH "/callhistory"
+#define CALLHIST_INTERFACE "com.jolla.CallHistory"
+#define CALLHIST_METHOD_FETCH_COUNT "Count"
+#define CALLHIST_METHOD_FETCH_ONE "FetchById"
+#define CALLHIST_METHOD_FETCH_MANY "Fetch"
+
+#define VERSION_UNSET 0
+
+#define PB_FORMAT_VCARD21 0
+#define PB_FORMAT_VCARD30 1
+
+static DBusConnection *conn = NULL;
+
+struct phonebook_session
+{
+	guint32 contacts_version;
+	guint32 callhist_version;
+};
+
+struct phonebook_data
+{
+	struct phonebook_session *session;
+	char *name;
+	const struct apparam_field *params;
+	phonebook_cb cb;
+	phonebook_entry_cb entry_cb;
+	phonebook_cache_ready_cb ready_cb;
+	void *user_data;
+	DBusPendingCall *pend;
+
+	void (*process_begin)(struct phonebook_data *data);
+	void (*process)(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard);
+	void (*process_end)(struct phonebook_data *data);
+
+	guint32 pull_count;
+	char *pull_buf;
+};
+
+static const char *name_to_calltype(const char *name)
+{
+	return
+		(g_strcmp0(name, PB_CALLS_INCOMING) == 0 ||
+			g_strcmp0(name, PB_CALLS_INCOMING_FOLDER) == 0)
+		? "inbound" :
+		(g_strcmp0(name, PB_CALLS_OUTGOING) == 0 ||
+			g_strcmp0(name, PB_CALLS_OUTGOING_FOLDER) == 0)
+		? "outbound" :
+		(g_strcmp0(name, PB_CALLS_MISSED) == 0 ||
+			g_strcmp0(name, PB_CALLS_MISSED_FOLDER) == 0)
+		? "missed" :
+		(g_strcmp0(name, PB_CALLS_COMBINED) == 0 ||
+			g_strcmp0(name, PB_CALLS_COMBINED_FOLDER) == 0)
+		? "combined" :
+		NULL;
+}
+
+static void count_cb(DBusPendingCall *pend,
+		     void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter;
+	guint32 count = 0, version;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		// ...
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "uu") != 0) {
+		// ...
+		goto done;
+	}
+
+	// TODO: check data version hasn't changed during the session
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_get_basic(&iter, &version);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_get_basic(&iter, &count);
+	DBG("count: %d", count);
+
+done:
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+        data->cb(NULL, 0, count, 0, TRUE, data->user_data);
+}
+
+static void pull_begin(struct phonebook_data *data)
+{
+	g_free(data->pull_buf);
+	data->pull_buf = NULL;
+	data->pull_count = 0;
+}
+
+static void pull_process(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard)
+{
+	data->pull_count++;
+	if (data->pull_buf == NULL)
+		data->pull_buf = g_strdup(vcard);
+	else
+		data->pull_buf = g_strconcat(data->pull_buf, vcard, NULL);
+}
+
+static void pull_end(struct phonebook_data *data)
+{
+	char *buf = data->pull_buf;
+	guint32 count = data->pull_count;
+	data->pull_buf = NULL;
+	data->pull_count = 0;
+
+	data->cb(buf, buf ? strlen(buf) : 0, count, 0, TRUE, data->user_data);
+
+	g_free(buf);
+}
+
+static void cache_begin(struct phonebook_data *data)
+{
+}
+
+static void cache_process(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard)
+{
+	(data->entry_cb)(id, PHONEBOOK_INVALID_HANDLE, name,
+			"", tel, data->user_data);
+}
+
+static void cache_end(struct phonebook_data *data)
+{
+	(data->ready_cb)(data->user_data);
+}
+
+static void fetch_one_cb(DBusPendingCall *pend,
+			void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter, struct_iter;
+	char *id;
+	char *name;
+	char *tel;
+	char *vcard;
+	guint32 version;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	(data->process_begin)(data);
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		DBG("D-Bus error");
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "u(ssss)") != 0) {
+		DBG("Unexpected D-Bus signature");
+		goto done;
+	}
+
+	// TODO: check data version hasn't changed during the session
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_get_basic(&iter, &version);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &id);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &name);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &tel);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &vcard);
+
+	DBG("id: %s, name: %s, tel: %s, vcard: %s", id, name, tel, vcard);
+	(data->process)(data, id, name, tel, vcard);
+
+done:
+	DBG("Finalizing. ");
+
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+	(data->process_end)(data);
+}
+
+static void fetch_many_cb(DBusPendingCall *pend,
+			void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter, array_iter, struct_iter;
+	guint32 version;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	(data->process_begin)(data);
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		// ...
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "ua(ssss)") != 0) {
+		// ...
+		goto done;
+	}
+
+	// TODO: check data version hasn't changed during the session
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_get_basic(&iter, &version);
+	dbus_message_iter_next(&iter);
+	dbus_message_iter_recurse(&iter, &array_iter);
+	while (dbus_message_iter_get_arg_type(&array_iter) !=
+		DBUS_TYPE_INVALID) {
+		char *id;
+		char *name;
+		char *tel;
+		char *vcard;
+		dbus_message_iter_recurse(&array_iter, &struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &id);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &name);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &tel);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &vcard);
+
+		DBG("id: %s, name: %s, tel:%s, vcard: %s",
+			id, name, tel, vcard);
+		(data->process)(data, id, name, tel, vcard);
+
+		dbus_message_iter_next(&array_iter);
+	}
+
+done:
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+	(data->process_end)(data);
+}
+
+int phonebook_init(void)
+{
+	DBG("");
+
+	conn = manager_dbus_get_connection();
+	if (conn == NULL)
+		return -1;
+
+	return 0;
+}
+
+void phonebook_exit(void)
+{
+	DBG("");
+
+	dbus_connection_unref(conn);
+}
+
+int phonebook_connect(void **session)
+{
+	struct phonebook_session *phonebook_session = 
+		g_new0(struct phonebook_session, 1);
+	phonebook_session->contacts_version = VERSION_UNSET;
+	phonebook_session->callhist_version = VERSION_UNSET;
+	*session = phonebook_session;
+	return 0;
+}
+
+void phonebook_disconnect(void *session)
+{
+	g_free(session);
+}
+
+char *phonebook_set_folder(void *session, const char *current_folder,
+		const char *new_folder, uint8_t flags, int *err)
+{
+	gboolean root, child;
+	char *tmp1, *tmp2, *base, *path = NULL;
+	int len, ret = 0;
+
+	DBG("current:'%s', new:'%s', flags:%x",
+		current_folder, new_folder, flags);
+
+	root = (g_strcmp0("/", current_folder) == 0);
+	child = (new_folder && strlen(new_folder) != 0);
+
+	switch (flags) {
+	case 0x02:
+		/* Go back to root */
+		if (!child) {
+			path = g_strdup("/");
+			goto done;
+		}
+
+		path = g_build_filename(current_folder, new_folder, NULL);
+		break;
+	case 0x03:
+		/* Go up 1 level */
+		if (root) {
+			/* Already root */
+			ret = -EBADR;
+			goto done;
+		}
+
+		/*
+		 * Removing one level of the current folder. Current folder
+		 * contains AT LEAST one level since it is not at root folder.
+		 * Use glib utility functions to handle invalid chars in the
+		 * folder path properly.
+		 */
+		tmp1 = g_path_get_basename(current_folder);
+		tmp2 = g_strrstr(current_folder, tmp1);
+		len = tmp2 - (current_folder + 1);
+
+		g_free(tmp1);
+
+		if (len == 0)
+			base = g_strdup("/");
+		else
+			base = g_strndup(current_folder, len);
+
+		/* Return: one level only */
+		if (!child) {
+			path = base;
+			goto done;
+		}
+
+		path = g_build_filename(base, new_folder, NULL);
+		g_free(base);
+
+		break;
+	default:
+		ret = -EBADR;
+		break;
+	}
+
+done:
+	if (!path) {
+		if (err)
+			*err = ret;
+
+		return NULL;
+	}
+
+	if (err)
+		*err = ret;
+
+	return path;
+}
+
+void *phonebook_pull(void *session, const char *name,
+		const struct apparam_field *params, phonebook_cb cb,
+		void *user_data, int *err)
+{
+	struct phonebook_data *data;
+
+	DBG("name %s", name);
+
+	data = g_new0(struct phonebook_data, 1);
+	data->session = session;
+	data->name = g_strdup(name);
+	data->params = params;
+	data->user_data = user_data;
+	data->cb = cb;
+
+	data->process_begin = pull_begin;
+	data->process = pull_process;
+	data->process_end = pull_end;
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+int phonebook_pull_read(void *request)
+{
+	struct phonebook_data *data = request;
+	DBusMessage *msg = NULL;
+	void (*cb)(DBusPendingCall *, void *) = NULL;
+	const char *fmt = NULL;
+
+	DBG("");
+
+	if (!data)
+		return -ENOENT;
+
+	fmt = data->params->format == PB_FORMAT_VCARD30
+		? "vcard30"
+		: "vcard21";
+
+	if (g_strcmp0(data->name, PB_CONTACTS) == 0) {
+
+		if (data->params->maxlistcount == 0) {
+			DBG("Fetching contact count");
+			msg = dbus_message_new_method_call
+				(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_COUNT);
+			cb = count_cb;
+		} else {
+			uint32_t off32 = data->params->liststartoffset;
+			uint32_t len32 = data->params->maxlistcount;
+			DBG("Fetching %u contacts starting at position %u, "
+				"formatting as '%s'", len32, off32, fmt);
+			msg = dbus_message_new_method_call
+				(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_MANY);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_UINT32, &off32,
+						DBUS_TYPE_UINT32, &len32,
+						DBUS_TYPE_STRING, &fmt,
+						DBUS_TYPE_INVALID);
+			cb = fetch_many_cb;
+		}
+
+	} else if (g_strcmp0(data->name, PB_CALLS_INCOMING) == 0 ||
+		g_strcmp0(data->name, PB_CALLS_OUTGOING) == 0 ||
+		g_strcmp0(data->name, PB_CALLS_MISSED) == 0 ||
+		g_strcmp0(data->name, PB_CALLS_COMBINED) == 0) {
+
+		const char *type = name_to_calltype(data->name);
+
+		if (data->params->maxlistcount == 0) {
+			DBG("Fetching call count");
+			msg = dbus_message_new_method_call
+				(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_COUNT);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_STRING, &type,
+						DBUS_TYPE_INVALID);
+			cb = count_cb;
+		} else {
+			uint32_t off32 = data->params->liststartoffset;
+			uint32_t len32 = data->params->maxlistcount;
+			DBG("Fetching %u calls starting at position %u ",
+				len32, off32);
+			msg = dbus_message_new_method_call
+				(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_MANY);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_STRING, &type,
+						DBUS_TYPE_UINT32, &off32,
+						DBUS_TYPE_UINT32, &len32,
+						DBUS_TYPE_STRING, &fmt,
+						DBUS_TYPE_INVALID);
+			cb = fetch_many_cb;
+		}
+
+	} else {
+		return -ENOENT;
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				cb,
+				data,
+				NULL);
+	return 0;
+}
+
+void *phonebook_get_entry(void *session, const char *folder, const char *id,
+				const struct apparam_field *params,
+				phonebook_cb cb, void *user_data, int *err)
+{
+	struct phonebook_data *data;
+	DBusMessage *msg;
+	const char *fmt = NULL;
+
+	DBG("folder:%s, id:%s", folder, id);
+
+	if (g_strcmp0(folder, PB_CONTACTS_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_INCOMING_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_OUTGOING_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_MISSED_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_COMBINED_FOLDER)) {
+		if (err)
+			*err = -ENOENT;
+		return NULL;
+	}
+
+	data = g_new0(struct phonebook_data, 1);
+	data->session = session;
+	data->name = g_strdup(folder);
+	data->params = params;
+	data->user_data = user_data;
+	data->cb = cb;
+
+	data->process_begin = pull_begin;
+	data->process = pull_process;
+	data->process_end = pull_end;
+
+	fmt = data->params->format == PB_FORMAT_VCARD30
+		? "vcard30"
+		: "vcard21";
+
+	if (g_strcmp0(folder, PB_CONTACTS_FOLDER) == 0) {
+		DBG("Fetching contact entry");
+		msg = dbus_message_new_method_call
+			(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_ONE);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &id,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	} else {
+		const char *type = name_to_calltype(folder);
+		DBG("Fetching call history entry");
+		msg = dbus_message_new_method_call
+			(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_ONE);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &type,
+					DBUS_TYPE_STRING, &id,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				fetch_one_cb, 
+				data,
+				NULL);
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+void *phonebook_create_cache(void *session, const char *name,
+			phonebook_entry_cb entry_cb,
+			phonebook_cache_ready_cb ready_cb, void *user_data,
+			int *err)
+{
+	struct phonebook_data *data;
+	DBusMessage *msg;
+	uint32_t off32 = 0;
+	uint32_t len32 = ~0;
+	const char *fmt = "vcard21";
+
+	DBG("name %s", name);
+
+	if (g_strcmp0(name, PB_CONTACTS_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_INCOMING_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_OUTGOING_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_MISSED_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_COMBINED_FOLDER)) {
+		if (err)
+			*err = -ENOENT;
+		return NULL;
+	}
+
+	data = g_new0(struct phonebook_data, 1);
+	data->session = session;
+	data->name = g_strdup(name);
+	data->user_data = user_data;
+	data->entry_cb = entry_cb;
+	data->ready_cb = ready_cb;
+
+	data->process_begin = cache_begin;
+	data->process = cache_process;
+	data->process_end = cache_end;
+
+	if (g_strcmp0(name, PB_CONTACTS_FOLDER) == 0) {
+
+		DBG("Caching contacts");
+		msg = dbus_message_new_method_call
+			(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_MANY);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_UINT32, &off32,
+					DBUS_TYPE_UINT32, &len32,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	} else {
+		const char *type = name_to_calltype(name);
+
+		DBG("Caching call history");
+		msg = dbus_message_new_method_call
+			(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_MANY);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &type,
+					DBUS_TYPE_UINT32, &off32,
+					DBUS_TYPE_UINT32, &len32,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				fetch_many_cb,
+				data,
+				NULL);
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+void phonebook_req_finalize(void *request)
+{
+	struct phonebook_data *data = request;
+
+	DBG("");
+
+	if (!data)
+		return;
+
+	if (data->pend != NULL)
+		dbus_pending_call_cancel(data->pend);
+
+	g_free(data->pull_buf);
+	g_free(data->name);
+	g_free(data);
+}
diff -Naur obexd.orig/plugins/phonebook-sailfish.c~ obexd/plugins/phonebook-sailfish.c~
--- obexd.orig/plugins/phonebook-sailfish.c~	1970-01-01 02:00:00.000000000 +0200
+++ obexd/plugins/phonebook-sailfish.c~	2014-01-17 08:53:12.283457605 +0200
@@ -0,0 +1,665 @@
+/*
+ *  Phonebook access through D-Bus vCard and call history service
+ *
+ *  Copyright (C) 2013 Jolla Ltd.
+ *  Contact: Hannu Mallat <hannu.mallat@jollamobile.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <errno.h>
+#include <glib.h>
+#include <dbus/dbus.h>
+
+#include "log.h"
+#include "phonebook.h"
+#include "obex.h"
+#include "manager.h"
+
+#define CONTACTS_SERVICE "com.jolla.Contacts"
+#define CONTACTS_PATH "/contacts"
+#define CONTACTS_INTERFACE "com.jolla.ContactsProvider"
+#define CONTACTS_METHOD_FETCH_COUNT "Count"
+#define CONTACTS_METHOD_FETCH_ONE "FetchById"
+#define CONTACTS_METHOD_FETCH_MANY "Fetch"
+
+#define CALLHIST_SERVICE "com.jolla.CallHistory"
+#define CALLHIST_PATH "/callhistory"
+#define CALLHIST_INTERFACE "com.jolla.CallHistoryProvider"
+#define CALLHIST_METHOD_FETCH_COUNT "Count"
+#define CALLHIST_METHOD_FETCH_ONE "FetchById"
+#define CALLHIST_METHOD_FETCH_MANY "Fetch"
+
+static DBusConnection *conn = NULL;
+
+struct phonebook_data
+{
+	char *name;
+	const struct apparam_field *params;
+	phonebook_cb cb;
+	phonebook_entry_cb entry_cb;
+	phonebook_cache_ready_cb ready_cb;
+	void *user_data;
+	DBusPendingCall *pend;
+
+	void (*process_begin)(struct phonebook_data *data);
+	void (*process)(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard);
+	void (*process_end)(struct phonebook_data *data);
+
+	guint32 pull_count;
+	char *pull_buf;
+};
+
+static const char *name_to_calltype(const char *name)
+{
+	return
+		(g_strcmp0(name, PB_CALLS_INCOMING) == 0 ||
+			g_strcmp0(name, PB_CALLS_INCOMING_FOLDER) == 0)
+		? "inbound" :
+		(g_strcmp0(name, PB_CALLS_OUTGOING) == 0 ||
+			g_strcmp0(name, PB_CALLS_OUTGOING_FOLDER) == 0)
+		? "outbound" :
+		(g_strcmp0(name, PB_CALLS_MISSED) == 0 ||
+			g_strcmp0(name, PB_CALLS_MISSED_FOLDER) == 0)
+		? "missed" :
+		(g_strcmp0(name, PB_CALLS_COMBINED) == 0 ||
+			g_strcmp0(name, PB_CALLS_COMBINED_FOLDER) == 0)
+		? "combined" :
+		NULL;
+}
+
+static void count_cb(DBusPendingCall *pend,
+		     void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter;
+	guint32 count = 0;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		// ...
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "u") != 0) {
+		// ...
+		goto done;
+	}
+
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_get_basic(&iter, &count);
+	DBG("count: %d", count);
+
+done:
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+        data->cb(NULL, 0, count, 0, TRUE, data->user_data);
+}
+
+static void pull_begin(struct phonebook_data *data)
+{
+	g_free(data->pull_buf);
+	data->pull_buf = NULL;
+	data->pull_count = 0;
+}
+
+static void pull_process(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard)
+{
+	data->pull_count++;
+	if (data->pull_buf == NULL)
+		data->pull_buf = g_strdup(vcard);
+	else
+		data->pull_buf = g_strconcat(data->pull_buf, vcard, NULL);
+}
+
+static void pull_end(struct phonebook_data *data)
+{
+	char *buf = data->pull_buf;
+	guint32 count = data->pull_count;
+	data->pull_buf = NULL;
+	data->pull_count = 0;
+
+	data->cb(buf, buf ? strlen(buf) : 0, count, 0, TRUE, data->user_data);
+
+	g_free(buf);
+}
+
+static void cache_begin(struct phonebook_data *data)
+{
+}
+
+static void cache_process(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard)
+{
+	(data->entry_cb)(id, PHONEBOOK_INVALID_HANDLE, name,
+			"", tel, data->user_data);
+}
+
+static void cache_end(struct phonebook_data *data)
+{
+	(data->ready_cb)(data->user_data);
+}
+
+static void fetch_one_cb(DBusPendingCall *pend,
+			void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter, struct_iter;
+	char *id;
+	char *name;
+	char *tel;
+	char *vcard;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	(data->process_begin)(data);
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		DBG("D-Bus error");
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "(ssss)") != 0) {
+		DBG("Unexpected D-Bus signature");
+		goto done;
+	}
+
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_recurse(&iter, &struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &id);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &name);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &tel);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &vcard);
+
+	DBG("id: %s, name: %s, tel: %s, vcard: %s", id, name, tel, vcard);
+	(data->process)(data, id, name, tel, vcard);
+
+done:
+	DBG("Finalizing. ");
+
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+	(data->process_end)(data);
+}
+
+static void fetch_many_cb(DBusPendingCall *pend,
+			void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter, array_iter, struct_iter;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	(data->process_begin)(data);
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		// ...
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "a(ssss)") != 0) {
+		// ...
+		goto done;
+	}
+
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_recurse(&iter, &array_iter);
+	while (dbus_message_iter_get_arg_type(&array_iter) !=
+		DBUS_TYPE_INVALID) {
+		char *id;
+		char *name;
+		char *tel;
+		char *vcard;
+		dbus_message_iter_recurse(&array_iter, &struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &id);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &name);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &tel);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &vcard);
+
+		DBG("id: %s, name: %s, tel:%s, vcard: %s",
+			id, name, tel, vcard);
+		(data->process)(data, id, name, tel, vcard);
+
+		dbus_message_iter_next(&array_iter);
+	}
+
+done:
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+	(data->process_end)(data);
+}
+
+int phonebook_init(void)
+{
+	DBG("");
+
+	conn = manager_dbus_get_connection();
+	if (conn == NULL)
+		return -1;
+
+	return 0;
+}
+
+void phonebook_exit(void)
+{
+	DBG("");
+
+	dbus_connection_unref(conn);
+}
+
+char *phonebook_set_folder(const char *current_folder,
+		const char *new_folder, uint8_t flags, int *err)
+{
+	gboolean root, child;
+	char *tmp1, *tmp2, *base, *path = NULL;
+	int len, ret = 0;
+
+	DBG("current:'%s', new:'%s', flags:%x",
+		current_folder, new_folder, flags);
+
+	root = (g_strcmp0("/", current_folder) == 0);
+	child = (new_folder && strlen(new_folder) != 0);
+
+	switch (flags) {
+	case 0x02:
+		/* Go back to root */
+		if (!child) {
+			path = g_strdup("/");
+			goto done;
+		}
+
+		path = g_build_filename(current_folder, new_folder, NULL);
+		break;
+	case 0x03:
+		/* Go up 1 level */
+		if (root) {
+			/* Already root */
+			ret = -EBADR;
+			goto done;
+		}
+
+		/*
+		 * Removing one level of the current folder. Current folder
+		 * contains AT LEAST one level since it is not at root folder.
+		 * Use glib utility functions to handle invalid chars in the
+		 * folder path properly.
+		 */
+		tmp1 = g_path_get_basename(current_folder);
+		tmp2 = g_strrstr(current_folder, tmp1);
+		len = tmp2 - (current_folder + 1);
+
+		g_free(tmp1);
+
+		if (len == 0)
+			base = g_strdup("/");
+		else
+			base = g_strndup(current_folder, len);
+
+		/* Return: one level only */
+		if (!child) {
+			path = base;
+			goto done;
+		}
+
+		path = g_build_filename(base, new_folder, NULL);
+		g_free(base);
+
+		break;
+	default:
+		ret = -EBADR;
+		break;
+	}
+
+done:
+	if (!path) {
+		if (err)
+			*err = ret;
+
+		return NULL;
+	}
+
+	if (err)
+		*err = ret;
+
+	return path;
+}
+
+void *phonebook_pull(const char *name, const struct apparam_field *params,
+				phonebook_cb cb, void *user_data, int *err)
+{
+	struct phonebook_data *data;
+
+	DBG("name %s", name);
+
+	data = g_new0(struct phonebook_data, 1);
+	data->name = g_strdup(name);
+	data->params = params;
+	data->user_data = user_data;
+	data->cb = cb;
+
+	data->process_begin = pull_begin;
+	data->process = pull_process;
+	data->process_end = pull_end;
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+int phonebook_pull_read(void *request)
+{
+	struct phonebook_data *data = request;
+	DBusMessage *msg = NULL;
+	void (*cb)(DBusPendingCall *, void *) = NULL;
+	const char *fmt = "vcard21"; // TBD
+
+	DBG("");
+
+	if (!data)
+		return -ENOENT;
+
+	if (g_strcmp0(data->name, PB_CONTACTS) == 0) {
+
+		if (data->params->maxlistcount == 0) {
+			DBG("Fetching contact count");
+			msg = dbus_message_new_method_call
+				(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_COUNT);
+			cb = count_cb;
+		} else {
+			uint32_t off32 = data->params->liststartoffset;
+			uint32_t len32 = data->params->maxlistcount;
+			DBG("Fetching %u contacts starting at position %u, "
+				"formatting as '%s'", off32, len32, fmt);
+			msg = dbus_message_new_method_call
+				(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_MANY);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_UINT32, &off32,
+						DBUS_TYPE_UINT32, &len32,
+						DBUS_TYPE_STRING, &fmt,
+						DBUS_TYPE_INVALID);
+			cb = fetch_many_cb;
+		}
+
+	} else if (g_strcmp0(data->name, PB_CALLS_INCOMING) == 0 ||
+		g_strcmp0(data->name, PB_CALLS_OUTGOING) == 0 ||
+		g_strcmp0(data->name, PB_CALLS_MISSED) == 0 ||
+		g_strcmp0(data->name, PB_CALLS_COMBINED) == 0) {
+
+		const char *type = name_to_calltype(data->name);
+
+		if (data->params->maxlistcount == 0) {
+			DBG("Fetching call count");
+			msg = dbus_message_new_method_call
+				(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_COUNT);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_STRING, &type,
+						DBUS_TYPE_INVALID);
+			cb = count_cb;
+		} else {
+			uint32_t off32 = data->params->liststartoffset;
+			uint32_t len32 = data->params->maxlistcount;
+			DBG("Fetching %u calls starting at position %u ",
+				off32, len32);
+			msg = dbus_message_new_method_call
+				(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_MANY);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_STRING, &type,
+						DBUS_TYPE_UINT32, &off32,
+						DBUS_TYPE_UINT32, &len32,
+						DBUS_TYPE_STRING, &fmt,
+						DBUS_TYPE_INVALID);
+			cb = fetch_many_cb;
+		}
+
+	} else {
+		return -ENOENT;
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				cb,
+				data,
+				NULL);
+	return 0;
+}
+
+void *phonebook_get_entry(const char *folder, const char *id,
+				const struct apparam_field *params,
+				phonebook_cb cb, void *user_data, int *err)
+{
+	struct phonebook_data *data;
+	DBusMessage *msg;
+	const char *fmt = "vcard21"; // TBD
+
+	DBG("folder:%s, id:%s", folder, id);
+
+	if (g_strcmp0(folder, PB_CONTACTS_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_INCOMING_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_OUTGOING_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_MISSED_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_COMBINED_FOLDER)) {
+		if (err)
+			*err = -ENOENT;
+		return NULL;
+	}
+
+	data = g_new0(struct phonebook_data, 1);
+	data->name = g_strdup(folder);
+	data->params = params;
+	data->user_data = user_data;
+	data->cb = cb;
+
+	data->process_begin = pull_begin;
+	data->process = pull_process;
+	data->process_end = pull_end;
+
+	if (g_strcmp0(folder, PB_CONTACTS_FOLDER) == 0) {
+		DBG("Fetching contact entry");
+		msg = dbus_message_new_method_call
+			(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_ONE);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &id,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	} else {
+		const char *type = name_to_calltype(folder);
+		DBG("Fetching call history entry");
+		msg = dbus_message_new_method_call
+			(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_ONE);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &type,
+					DBUS_TYPE_STRING, &id,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				fetch_one_cb, 
+				data,
+				NULL);
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+void *phonebook_create_cache(const char *name, phonebook_entry_cb entry_cb,
+		phonebook_cache_ready_cb ready_cb, void *user_data, int *err)
+{
+	struct phonebook_data *data;
+	DBusMessage *msg;
+	uint32_t off32 = 0;
+	uint32_t len32 = ~0;
+	const char *fmt = "vcard21"; // TBD
+
+	DBG("name %s", name);
+
+	if (g_strcmp0(name, PB_CONTACTS_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_INCOMING_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_OUTGOING_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_MISSED_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_COMBINED_FOLDER)) {
+		if (err)
+			*err = -ENOENT;
+		return NULL;
+	}
+
+	data = g_new0(struct phonebook_data, 1);
+	data->name = g_strdup(name);
+	data->user_data = user_data;
+	data->entry_cb = entry_cb;
+	data->ready_cb = ready_cb;
+
+	data->process_begin = cache_begin;
+	data->process = cache_process;
+	data->process_end = cache_end;
+
+	if (g_strcmp0(name, PB_CONTACTS_FOLDER) == 0) {
+
+		DBG("Caching contacts");
+		msg = dbus_message_new_method_call
+			(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_MANY);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_UINT32, &off32,
+					DBUS_TYPE_UINT32, &len32,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	} else {
+		const char *type = name_to_calltype(name);
+
+		DBG("Caching call history");
+		msg = dbus_message_new_method_call
+			(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_MANY);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &type,
+					DBUS_TYPE_UINT32, &off32,
+					DBUS_TYPE_UINT32, &len32,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				fetch_many_cb,
+				data,
+				NULL);
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+void phonebook_req_finalize(void *request)
+{
+	struct phonebook_data *data = request;
+
+	DBG("");
+
+	if (!data)
+		return;
+
+	if (data->pend != NULL)
+		dbus_pending_call_cancel(data->pend);
+
+	g_free(data->pull_buf);
+	g_free(data->name);
+	g_free(data);
+}
diff -Naur obexd.orig/plugins/phonebook-tracker.c obexd/plugins/phonebook-tracker.c
--- obexd.orig/plugins/phonebook-tracker.c	2014-01-17 08:52:59.481060135 +0200
+++ obexd/plugins/phonebook-tracker.c	2014-01-17 14:33:24.065748665 +0200
@@ -1440,8 +1440,18 @@
 {
 }
 
-char *phonebook_set_folder(const char *current_folder, const char *new_folder,
-						uint8_t flags, int *err)
+int phonebook_connect(void **session)
+{
+	return 0;
+}
+
+void phonebook_disconnect(void *session)
+{
+	return 0;
+}
+
+char *phonebook_set_folder(void *session, const char *current_folder,
+			const char *new_folder, uint8_t flags, int *err)
 {
 	char *tmp1, *tmp2, *base, *path = NULL;
 	gboolean root, child;
@@ -1580,8 +1590,9 @@
 	g_free(data);
 }
 
-void *phonebook_pull(const char *name, const struct apparam_field *params,
-				phonebook_cb cb, void *user_data, int *err)
+void *phonebook_pull(void *session, const char *name,
+		const struct apparam_field *params, phonebook_cb cb,
+		void *user_data, int *err)
 {
 	struct phonebook_data *data;
 
@@ -1650,7 +1661,7 @@
 	return query_tracker(query, col_amount, pull_cb, data);
 }
 
-void *phonebook_get_entry(const char *folder, const char *id,
+void *phonebook_get_entry(void *session, const char *folder, const char *id,
 				const struct apparam_field *params,
 				phonebook_cb cb, void *user_data, int *err)
 {
@@ -1685,8 +1696,10 @@
 	return data;
 }
 
-void *phonebook_create_cache(const char *name, phonebook_entry_cb entry_cb,
-		phonebook_cache_ready_cb ready_cb, void *user_data, int *err)
+void *phonebook_create_cache(void *session, const char *name,
+			phonebook_entry_cb entry_cb,
+			phonebook_cache_ready_cb ready_cb, void *user_data,
+			int *err)
 {
 	struct phonebook_data *data;
 	const char *query;
