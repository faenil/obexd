diff -Naur obexd.orig/Makefile.am obexd/Makefile.am
--- obexd.orig/Makefile.am	2013-11-18 08:01:13.845244096 +0200
+++ obexd/Makefile.am	2013-11-18 09:35:15.933051478 +0200
@@ -149,6 +149,7 @@
 			src/obexd.service.in client/obex-client.service.in \
 			plugins/phonebook-dummy.c plugins/phonebook-ebook.c \
 			plugins/phonebook-tracker.c \
+			plugins/phonebook-sailfish.c \
 			plugins/messages-dummy.c plugins/messages-tracker.c
 
 DISTCHECK_CONFIGURE_FLAGS = --enable-client --enable-server
diff -Naur obexd.orig/plugins/pbap.c obexd/plugins/pbap.c
--- obexd.orig/plugins/pbap.c	2013-11-18 08:01:13.845244096 +0200
+++ obexd/plugins/pbap.c	2013-11-29 17:04:15.835157354 +0200
@@ -233,6 +233,7 @@
 
 	phonebooksize = htons(vcards);
 
+	pbap->obj->firstpacket = TRUE;
 	pbap->obj->apparam = g_obex_apparam_set_uint16(NULL, PHONEBOOKSIZE_TAG,
 								phonebooksize);
 
@@ -873,7 +874,7 @@
 
 	*hi = G_OBEX_HDR_APPARAM;
 
-	if (pbap->params->maxlistcount == 0 || obj->firstpacket) {
+	if (obj->firstpacket) {
 		obj->firstpacket = FALSE;
 
 		return g_obex_apparam_encode(obj->apparam, buf, mtu);
diff -Naur obexd.orig/plugins/phonebook-sailfish.c obexd/plugins/phonebook-sailfish.c
--- obexd.orig/plugins/phonebook-sailfish.c	1970-01-01 02:00:00.000000000 +0200
+++ obexd/plugins/phonebook-sailfish.c	2013-11-29 13:41:25.037554712 +0200
@@ -0,0 +1,657 @@
+/*
+ *  Phonebook access through D-Bus vCard and call history service
+ *
+ *  Copyright (C) 2013 Jolla Ltd.
+ *  Contact: Hannu Mallat <hannu.mallat@jollamobile.com>
+ *
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <errno.h>
+#include <glib.h>
+#include <dbus/dbus.h>
+
+#include "log.h"
+#include "phonebook.h"
+#include "obex.h"
+#include "manager.h"
+
+#define CONTACTS_SERVICE "com.jolla.Contacts"
+#define CONTACTS_PATH "/contacts"
+#define CONTACTS_INTERFACE "com.jolla.ContactsProvider"
+#define CONTACTS_METHOD_FETCH_COUNT "Count"
+#define CONTACTS_METHOD_FETCH_ONE "FetchById"
+#define CONTACTS_METHOD_FETCH_MANY "Fetch"
+
+#define CALLHIST_SERVICE "com.jolla.CallHistory"
+#define CALLHIST_PATH "/callhistory"
+#define CALLHIST_INTERFACE "com.jolla.CallHistoryProvider"
+#define CALLHIST_METHOD_FETCH_COUNT "Count"
+#define CALLHIST_METHOD_FETCH_ONE "FetchById"
+#define CALLHIST_METHOD_FETCH_MANY "Fetch"
+
+static DBusConnection *conn = NULL;
+
+struct phonebook_data
+{
+	char *name;
+	const struct apparam_field *params;
+	phonebook_cb cb;
+	phonebook_entry_cb entry_cb;
+	phonebook_cache_ready_cb ready_cb;
+	void *user_data;
+	DBusPendingCall *pend;
+
+	void (*process_begin)(struct phonebook_data *data);
+	void (*process)(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard);
+	void (*process_end)(struct phonebook_data *data);
+
+	guint32 pull_count;
+	char *pull_buf;
+};
+
+static const char *name_to_calltype(const char *name)
+{
+	return
+		(g_strcmp0(name, PB_CALLS_INCOMING) == 0 ||
+			g_strcmp0(name, PB_CALLS_INCOMING_FOLDER) == 0)
+		? "inbound" :
+		(g_strcmp0(name, PB_CALLS_OUTGOING) == 0 ||
+			g_strcmp0(name, PB_CALLS_OUTGOING_FOLDER) == 0)
+		? "outbound" :
+		(g_strcmp0(name, PB_CALLS_MISSED) == 0 ||
+			g_strcmp0(name, PB_CALLS_MISSED_FOLDER) == 0)
+		? "missed" :
+		NULL;
+}
+
+static void count_cb(DBusPendingCall *pend,
+		     void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter;
+	guint32 count = 0;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		// ...
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "u") != 0) {
+		// ...
+		goto done;
+	}
+
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_get_basic(&iter, &count);
+	DBG("count: %d", count);
+
+done:
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+        data->cb(NULL, 0, count, 0, TRUE, data->user_data);
+}
+
+static void pull_begin(struct phonebook_data *data)
+{
+	g_free(data->pull_buf);
+	data->pull_buf = NULL;
+	data->pull_count = 0;
+}
+
+static void pull_process(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard)
+{
+	data->pull_count++;
+	if (data->pull_buf == NULL)
+		data->pull_buf = g_strdup(vcard);
+	else
+		data->pull_buf = g_strconcat(data->pull_buf, vcard, NULL);
+}
+
+static void pull_end(struct phonebook_data *data)
+{
+	char *buf = data->pull_buf;
+	guint32 count = data->pull_count;
+	data->pull_buf = NULL;
+	data->pull_count = 0;
+
+	data->cb(buf, buf ? strlen(buf) : 0, count, 0, TRUE, data->user_data);
+
+	g_free(buf);
+}
+
+static void cache_begin(struct phonebook_data *data)
+{
+}
+
+static void cache_process(struct phonebook_data *data,
+			const char *id,
+			const char *name,
+			const char *tel,
+			const char *vcard)
+{
+	(data->entry_cb)(id, PHONEBOOK_INVALID_HANDLE, name,
+			"", tel, data->user_data);
+}
+
+static void cache_end(struct phonebook_data *data)
+{
+	(data->ready_cb)(data->user_data);
+}
+
+static void fetch_one_cb(DBusPendingCall *pend,
+			void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter, struct_iter;
+	char *id;
+	char *name;
+	char *tel;
+	char *vcard;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	(data->process_begin)(data);
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		// ...
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "(ssss)") != 0) {
+		// ...
+		goto done;
+	}
+
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_recurse(&iter, &struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &id);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &name);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &tel);
+	dbus_message_iter_next(&struct_iter);
+	dbus_message_iter_get_basic(&struct_iter, &vcard);
+
+	DBG("id: %s, name: %s, tel: %s, vcard: %s", id, name, tel, vcard);
+	(data->process)(data, id, name, tel, vcard);
+
+done:
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+	(data->process_end)(data);
+}
+
+static void fetch_many_cb(DBusPendingCall *pend,
+			void *user_data)
+{
+	struct phonebook_data *data = user_data;
+	DBusMessage *reply = NULL;
+	DBusMessageIter iter, array_iter, struct_iter;
+
+	DBG("");
+
+	reply = dbus_pending_call_steal_reply(data->pend);
+	if (reply == NULL)
+		return;
+
+	(data->process_begin)(data);
+
+	if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
+		// ...
+		goto done;
+	}
+
+	if (g_strcmp0(dbus_message_get_signature(reply), "a(ssss)") != 0) {
+		// ...
+		goto done;
+	}
+
+	dbus_message_iter_init(reply, &iter);
+	dbus_message_iter_recurse(&iter, &array_iter);
+	while (dbus_message_iter_get_arg_type(&array_iter) !=
+		DBUS_TYPE_INVALID) {
+		char *id;
+		char *name;
+		char *tel;
+		char *vcard;
+		dbus_message_iter_recurse(&array_iter, &struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &id);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &name);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &tel);
+		dbus_message_iter_next(&struct_iter);
+		dbus_message_iter_get_basic(&struct_iter, &vcard);
+
+		DBG("id: %s, name: %s, tel:%s, vcard: %s",
+			id, name, tel, vcard);
+		(data->process)(data, id, name, tel, vcard);
+
+		dbus_message_iter_next(&array_iter);
+	}
+
+done:
+	dbus_message_unref(reply);
+	dbus_pending_call_unref(data->pend);
+	data->pend = NULL;
+
+	(data->process_end)(data);
+}
+
+int phonebook_init(void)
+{
+	DBG("");
+
+	conn = manager_dbus_get_connection();
+	if (conn == NULL)
+		return -1;
+
+	return 0;
+}
+
+void phonebook_exit(void)
+{
+	DBG("");
+
+	dbus_connection_unref(conn);
+}
+
+char *phonebook_set_folder(const char *current_folder,
+		const char *new_folder, uint8_t flags, int *err)
+{
+	gboolean root, child;
+	char *tmp1, *tmp2, *base, *path = NULL;
+	int len, ret = 0;
+
+	DBG("current:'%s', new:'%s', flags:%x",
+		current_folder, new_folder, flags);
+
+	root = (g_strcmp0("/", current_folder) == 0);
+	child = (new_folder && strlen(new_folder) != 0);
+
+	switch (flags) {
+	case 0x02:
+		/* Go back to root */
+		if (!child) {
+			path = g_strdup("/");
+			goto done;
+		}
+
+		path = g_build_filename(current_folder, new_folder, NULL);
+		break;
+	case 0x03:
+		/* Go up 1 level */
+		if (root) {
+			/* Already root */
+			ret = -EBADR;
+			goto done;
+		}
+
+		/*
+		 * Removing one level of the current folder. Current folder
+		 * contains AT LEAST one level since it is not at root folder.
+		 * Use glib utility functions to handle invalid chars in the
+		 * folder path properly.
+		 */
+		tmp1 = g_path_get_basename(current_folder);
+		tmp2 = g_strrstr(current_folder, tmp1);
+		len = tmp2 - (current_folder + 1);
+
+		g_free(tmp1);
+
+		if (len == 0)
+			base = g_strdup("/");
+		else
+			base = g_strndup(current_folder, len);
+
+		/* Return: one level only */
+		if (!child) {
+			path = base;
+			goto done;
+		}
+
+		path = g_build_filename(base, new_folder, NULL);
+		g_free(base);
+
+		break;
+	default:
+		ret = -EBADR;
+		break;
+	}
+
+done:
+	if (!path) {
+		if (err)
+			*err = ret;
+
+		return NULL;
+	}
+
+	if (err)
+		*err = ret;
+
+	return path;
+}
+
+void *phonebook_pull(const char *name, const struct apparam_field *params,
+				phonebook_cb cb, void *user_data, int *err)
+{
+	struct phonebook_data *data;
+
+	DBG("name %s", name);
+
+	data = g_new0(struct phonebook_data, 1);
+	data->name = g_strdup(name);
+	data->params = params;
+	data->user_data = user_data;
+	data->cb = cb;
+
+	data->process_begin = pull_begin;
+	data->process = pull_process;
+	data->process_end = pull_end;
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+int phonebook_pull_read(void *request)
+{
+	struct phonebook_data *data = request;
+	DBusMessage *msg = NULL;
+	void (*cb)(DBusPendingCall *, void *) = NULL;
+	const char *fmt = "vcard21"; // TBD
+
+	DBG("");
+
+	if (!data)
+		return -ENOENT;
+
+	if (g_strcmp0(data->name, PB_CONTACTS) == 0) {
+
+		if (data->params->maxlistcount == 0) {
+			DBG("Fetching contact count");
+			msg = dbus_message_new_method_call
+				(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_COUNT);
+			cb = count_cb;
+		} else {
+			uint32_t off32 = data->params->liststartoffset;
+			uint32_t len32 = data->params->maxlistcount;
+			DBG("Fetching %u contacts starting at position %u, "
+				"formatting as '%s'", off32, len32, fmt);
+			msg = dbus_message_new_method_call
+				(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_MANY);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_UINT32, &off32,
+						DBUS_TYPE_UINT32, &len32,
+						DBUS_TYPE_STRING, &fmt,
+						DBUS_TYPE_INVALID);
+			cb = fetch_many_cb;
+		}
+
+	} else if (g_strcmp0(data->name, PB_CALLS_INCOMING) == 0 ||
+		g_strcmp0(data->name, PB_CALLS_OUTGOING) == 0 ||
+		g_strcmp0(data->name, PB_CALLS_MISSED) == 0) {
+
+		const char *type = name_to_calltype(data->name);
+
+		if (data->params->maxlistcount == 0) {
+			DBG("Fetching call count");
+			msg = dbus_message_new_method_call
+				(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_COUNT);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_STRING, &type,
+						DBUS_TYPE_INVALID);
+			cb = count_cb;
+		} else {
+			uint32_t off32 = data->params->liststartoffset;
+			uint32_t len32 = data->params->maxlistcount;
+			DBG("Fetching %u calls starting at position %u ",
+				off32, len32);
+			msg = dbus_message_new_method_call
+				(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_MANY);
+			dbus_message_append_args(msg,
+						DBUS_TYPE_STRING, &type,
+						DBUS_TYPE_UINT32, &off32,
+						DBUS_TYPE_UINT32, &len32,
+						DBUS_TYPE_STRING, &fmt,
+						DBUS_TYPE_INVALID);
+			cb = fetch_many_cb;
+		}
+
+	} else {
+		return -ENOENT;
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				cb,
+				data,
+				NULL);
+	return 0;
+}
+
+void *phonebook_get_entry(const char *folder, const char *id,
+				const struct apparam_field *params,
+				phonebook_cb cb, void *user_data, int *err)
+{
+	struct phonebook_data *data;
+	DBusMessage *msg;
+	const char *fmt = "vcard21"; // TBD
+
+	DBG("folder:%s, id:%s", folder, id);
+
+	if (g_strcmp0(folder, PB_CONTACTS_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_INCOMING_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_OUTGOING_FOLDER) &&
+		g_strcmp0(folder, PB_CALLS_MISSED_FOLDER)) {
+		if (err)
+			*err = -ENOENT;
+		return NULL;
+	}
+
+	data = g_new0(struct phonebook_data, 1);
+	data->name = g_strdup(folder);
+	data->params = params;
+	data->user_data = user_data;
+	data->cb = cb;
+
+	data->process_begin = pull_begin;
+	data->process = pull_process;
+	data->process_end = pull_end;
+
+	if (g_strcmp0(folder, PB_CONTACTS_FOLDER) == 0) {
+		DBG("Fetching contact entry");
+		msg = dbus_message_new_method_call
+			(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_ONE);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &id,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	} else {
+		const char *type = name_to_calltype(folder);
+		DBG("Fetching call history entry");
+		msg = dbus_message_new_method_call
+			(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_ONE);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &type,
+					DBUS_TYPE_STRING, &id,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				fetch_one_cb, 
+				data,
+				NULL);
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+void *phonebook_create_cache(const char *name, phonebook_entry_cb entry_cb,
+		phonebook_cache_ready_cb ready_cb, void *user_data, int *err)
+{
+	struct phonebook_data *data;
+	DBusMessage *msg;
+	uint32_t off32 = 0;
+	uint32_t len32 = ~0;
+	const char *fmt = "vcard21"; // TBD
+
+	DBG("name %s", name);
+
+	if (g_strcmp0(name, PB_CONTACTS_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_INCOMING_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_OUTGOING_FOLDER) &&
+		g_strcmp0(name, PB_CALLS_MISSED_FOLDER)) {
+		if (err)
+			*err = -ENOENT;
+		return NULL;
+	}
+
+	data = g_new0(struct phonebook_data, 1);
+	data->name = g_strdup(name);
+	data->user_data = user_data;
+	data->entry_cb = entry_cb;
+	data->ready_cb = ready_cb;
+
+	data->process_begin = cache_begin;
+	data->process = cache_process;
+	data->process_end = cache_end;
+
+	if (g_strcmp0(name, PB_CONTACTS_FOLDER) == 0) {
+
+		DBG("Caching contacts");
+		msg = dbus_message_new_method_call
+			(CONTACTS_SERVICE,
+				CONTACTS_PATH,
+				CONTACTS_INTERFACE,
+				CONTACTS_METHOD_FETCH_MANY);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_UINT32, &off32,
+					DBUS_TYPE_UINT32, &len32,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	} else {
+		const char *type = name_to_calltype(name);
+
+		DBG("Caching call history");
+		msg = dbus_message_new_method_call
+			(CALLHIST_SERVICE,
+				CALLHIST_PATH,
+				CALLHIST_INTERFACE,
+				CALLHIST_METHOD_FETCH_MANY);
+		dbus_message_append_args(msg,
+					DBUS_TYPE_STRING, &type,
+					DBUS_TYPE_UINT32, &off32,
+					DBUS_TYPE_UINT32, &len32,
+					DBUS_TYPE_STRING, &fmt,
+					DBUS_TYPE_INVALID);
+	}
+
+	dbus_connection_send_with_reply(conn,
+					msg,
+					&data->pend,
+					DBUS_TIMEOUT_USE_DEFAULT);
+	dbus_pending_call_set_notify(data->pend,
+				fetch_many_cb,
+				data,
+				NULL);
+
+	if (err)
+		*err = 0;
+
+	return data;
+}
+
+void phonebook_req_finalize(void *request)
+{
+	struct phonebook_data *data = request;
+
+	DBG("");
+
+	if (!data)
+		return;
+
+	if (data->pend != NULL)
+		dbus_pending_call_cancel(data->pend);
+
+	g_free(data->pull_buf);
+	g_free(data->name);
+	g_free(data);
+}
